#!/usr/bin/env bash
set -euo pipefail
# A quick and dirty k8s configuration management tool.
# TODO:
#   - Add more robust replacements that can modify existing values.
#   - Rewrite in golang when POC is complete.

# Ensure the required dependencies are installed.
for d in jq yq kubectl envsubst; do which "$d" >/dev/null || {
  echo "not installed: $d"
  exit 1
}; done

# Configure the manifest file we'll be looking for.
ASSEMBLY_FILE="assembly.yml"

# Help...
if [[ $# -eq 0 ]]; then
  cat <<EOF
Usage: kubectl build <path>... | kubectl apply -f -

Assemble and configure yaml manifests from \`${ASSEMBLY_FILE}\` files.

resources:                           # resources specify yaml files to combine
                                     # into a single yaml output stream.
- path/to/file.yml                   # explicitly include a file
- path/to/bare/directory             # collect all yml files within
- path/to/assembly/directory         # when ${ASSEMBLY_FILE} in root, process it

vars:                                # vars specify variables that can be
                                     # overridden by environment variables.
- name: CLUSTER_HOST                 # name is the variable name
  value: test.com                    # value is an inline value for the var
  valueFromFile: path/to/file        # valueFromFile is an external file that
                                     # contains the desired value. valueFromFile
                                     # trumps value.

patches:                             # patches specify "indirect" modifications
                                     # to resources included in this file
- target:                            # start patch, every resource included will be compared
    kind: Service                    # against the keys under the target. target must be
    metadata:                        # specified fully enough to match exactly one manifest.
      name: my-service               # any keys/values can be used for matching.
  replacements:                      # start list of changes to make to manifest
  - path: spec.virtualhost.fqdn      # json path pointing to the field to modify
    value: service.\${CLUSTER_HOST}   # the value to insert
EOF
fi

# Assembly collects yaml manifests enumerated in an "assembly" file, applies
# patches defined within and streams the modified results to standard out.
function assembly() {
  # Save the directory that was used when this was invoked.
  local root=${1}
  # Save a path to the config file that may exist in the supplied directory.
  local configFile=${root}/${ASSEMBLY_FILE}
  # Attempt to read the configuration file. If it doesn't exist, this fails with
  # a clear error message.
  local config=$(
    # Do variable substitutions in a subshell so vars in one assembly do not
    # affect nested assemblys.
    local rawConfig=$(yq r -j ${configFile})
    # Attempt to load vars so configFile can be re-parsed to replace them.
    local vars=$(echo "${rawConfig}" | jq -cr '.vars[]')
    if [[ "${vars}" != "" ]]; then
      # Iterate through each variable, setting if it isn't already provided in
      # the environment.
      for var in ${vars}; do
        # Extract variable name.
        local name=$(jq -r '.name' <<<"${var}")
        # This insane garbage determines if the variable is set in the
        # environment already.
        if ! compgen -e -X "!$name" >/dev/null; then
          # If var is not set in environment, try to get the value from an
          # external file
          valueFromFile=$(jq -rc '.valueFromFile' <<<"${var}")
          if [[ "${valueFromFile}" != "null" ]]; then
            # Absent files will cause failures.
            value=$(cat ${root}/${valueFromFile})
          fi
          # If value hasn't been set yet, try to get it from inline declaration.
          if [[ "${value:-}" == "" ]]; then
            value=$(jq -re '.value' <<<"${var}")
          fi
          # Export value so envsubst will see it.
          eval export ${name}="${value}" >/dev/null
        fi
      done
    fi
    # Rebuild config using supplied environment variables.
    envsubst <<<"${rawConfig}"
  )
  # Save the resources enumerated in the assembly file, one per line.
  local resources=$(echo "${config}" | jq -cre '.resources[]')
  # Read all specified resources.
  manifests=$(
    cd ${root}
    for item in ${resources}; do
      if [[ -f "${item}/${ASSEMBLY_FILE}" ]]; then
        # If a resource points to a directory that contains an assembly file,
        # run assembly on it and collect the output. This is recursive and can
        # be nested as deeply as needed.
        assembly "${root}/${item}"
      else
        # If the resource pointed to does not contain an assembly file, collect
        # the raw file pointed to or, in the case of a directory, every file
        # within that has a .yml extension.
        collect "${root}/${item}"
      fi
    done
  )
  # Save the patches enumerated in the assembly file, one per line.
  local patches=$(echo "${config}" | jq -cr '.patches[]' 2>/dev/null)
  if [[ "${patches}" != "" ]]; then
    # Iterate through each patch, applying it to the desired target.
    for patch in ${patches}; do
      # Collect the target for the patch, this will be used to filter manifests
      # to find the one that should be modified.
      filter=$(echo "${patch}" | jq -rc '.target')
      # Collect the matching manifest based on the target provided.
      matched=$(echo "${manifests}" | jq -c 'select(contains('${filter}'))')
      # Check the number of manifests that matched the target.
      matchCount=$(echo "${matched}" | wc -l)
      # A patch can only target a single manifest (currently). If none or more
      # than one are found, error and exit.
      if [[ ${matchCount} != 1 ]]; then
        echo "Patch target in ${configFile} found ${matchCount} matches, wanted 1."
        echo "${matched}" | jq -c
        exit 1
      fi
      # Produce a JQ expression that can apply the replacements.
      replacements=$(echo "${patch}" | jq -r '.replacements | map("."+(.path)+" = "+(.value|tojson)) | join(" | ")')
      # Overwrite the manifest listing with modifications supplied, the next
      # loop through will do the same.
      manifests=$(
        # Output any manifest that didn't match.
        echo "${manifests}" | jq -c 'select(contains('${filter}') | not)'
        # Output matched manifest with replacements applied.
        echo "${matched}" | jq -c ". | ${replacements}"
      )
    done
  fi
  echo "${manifests}"
}

# collect takes the path to a file or a directory and produces jsonl output, one
# line for each manifest referenced.
function collect() {
  local target=${1}
  if [[ -d "${target}" ]]; then
    for file in $(find ${target} -type f -name "*.yml"); do
      expand "${file}"
    done
  else
    expand "${target}"
  fi
}

# expand converts a yaml file to json, splitting composite documents on ---.
function expand() {
  if ! grep -q -- "---" ${1}; then
    yq r -j ${1}
  else
    cat ${1} | while read -d'---' manifest || [[ -n $manifest ]]; do
      if [[ "${manifest}" != "" ]]; then
        echo "${manifest}" | yq r -j -
      fi
    done
  fi
}


# Try to run assembly on every provided path.
for dir in $*; do
  while read -r manifest; do
     yq r -P - <<<"${manifest}"
     echo "---"
  done <<<"$(assembly ${PWD}/${dir})"
done